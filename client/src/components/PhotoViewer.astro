---
export interface Photo {
  url: string;
  alt: string;
}

export interface Props {
  photos?: Photo[];
}
---

<div 
  id="photo-viewer" 
  class="fixed inset-0 z-[999] flex items-center justify-center bg-black/90 backdrop-blur-sm opacity-0 pointer-events-none transition-all duration-300 ease-out"
  data-viewer-active="false"
>
  <!-- Close button -->
  <button 
    id="viewer-close"
    class="absolute top-6 right-6 z-10 p-2 rounded-full bg-white/10 hover:bg-white/20 text-white transition-colors duration-200 group"
    aria-label="Close photo viewer"
    type="button"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="size-6 group-hover:rotate-90 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
    </svg>
  </button>

  <!-- Previous button -->
  <button 
    id="viewer-prev"
    class="absolute left-6 top-1/2 -translate-y-1/2 z-10 p-3 rounded-full bg-white/10 hover:bg-white/20 text-white transition-all duration-200 opacity-0 pointer-events-none group"
    aria-label="Previous photo"
    type="button"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="size-6 group-hover:-translate-x-1 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M15 19l-7-7 7-7" />
    </svg>
  </button>

  <!-- Next button -->
  <button 
    id="viewer-next"
    class="absolute right-6 top-1/2 -translate-y-1/2 z-10 p-3 rounded-full bg-white/10 hover:bg-white/20 text-white transition-all duration-200 opacity-0 pointer-events-none group"
    aria-label="Next photo"
    type="button"
  >
    <svg xmlns="http://www.w3.org/2000/svg" class="size-6 group-hover:translate-x-1 transition-transform duration-200" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
      <path stroke-linecap="round" stroke-linejoin="round" d="M9 5l7 7-7 7" />
    </svg>
  </button>

  <!-- Photo container -->
  <div class="relative w-full h-full flex items-center justify-center p-4">
    <!-- Loading indicator -->
    <div id="viewer-loading" class="absolute inset-0 flex items-center justify-center">
      <div class="animate-spin rounded-full h-12 w-12 border-2 border-white/20 border-t-white"></div>
    </div>

    <!-- Main image -->
    <img 
      id="viewer-image"
      src=""
      alt=""
      class="max-w-full max-h-full object-contain rounded-lg shadow-2xl opacity-0 transition-opacity duration-300"
      style="max-height: calc(100vh - 2rem);"
    />
    
    <!-- Photo info -->
    <div class="absolute bottom-6 left-1/2 -translate-x-1/2 flex items-center gap-4 px-4 py-2 bg-black/50 backdrop-blur-sm text-white text-sm rounded-full">
      <span id="viewer-counter">1 / 1</span>
      <div class="w-px h-4 bg-white/30"></div>
      <span id="viewer-title" class="max-w-xs truncate"></span>
    </div>
  </div>
</div>

<script>
  interface Photo {
    url: string;
    alt: string;
  }

  // Add interface for extended window properties
  interface WindowWithPhotoViewer extends Window {
    openPhotoViewer: (photos: Photo[], index?: number) => void;
    photoViewerReady: boolean;
  }

  class PhotoViewerSystem {
    private photos: Photo[] = [];
    private currentIndex: number = 0;
    private isActive: boolean = false;
    
    private viewer: HTMLElement;
    private image: HTMLImageElement;
    private loading: HTMLElement;
    private counter: HTMLElement;
    private title: HTMLElement;
    private closeBtn: HTMLButtonElement;
    private prevBtn: HTMLButtonElement;
    private nextBtn: HTMLButtonElement;

    constructor() {
      this.viewer = document.getElementById("photo-viewer") as HTMLElement;
      this.image = document.getElementById("viewer-image") as HTMLImageElement;
      this.loading = document.getElementById("viewer-loading") as HTMLElement;
      this.counter = document.getElementById("viewer-counter") as HTMLElement;
      this.title = document.getElementById("viewer-title") as HTMLElement;
      this.closeBtn = document.getElementById("viewer-close") as HTMLButtonElement;
      this.prevBtn = document.getElementById("viewer-prev") as HTMLButtonElement;
      this.nextBtn = document.getElementById("viewer-next") as HTMLButtonElement;

      if (this.viewer) {
        this.bindEvents();
      }
    }

    private bindEvents(): void {
      // Close button
      this.closeBtn?.addEventListener("click", (e) => {
        e.stopPropagation();
        this.close();
      });

      // Navigation buttons
      this.prevBtn?.addEventListener("click", (e) => {
        e.stopPropagation();
        this.previous();
      });

      this.nextBtn?.addEventListener("click", (e) => {
        e.stopPropagation();
        this.next();
      });

      // Click backdrop to close
      this.viewer?.addEventListener("click", (e) => {
        if (e.target === this.viewer) {
          this.close();
        }
      });

      // Keyboard navigation
      document.addEventListener("keydown", (e) => {
        if (!this.isActive) return;

        switch (e.key) {
          case "Escape":
            e.preventDefault();
            this.close();
            break;
          case "ArrowLeft":
            e.preventDefault();
            this.previous();
            break;
          case "ArrowRight":
            e.preventDefault();
            this.next();
            break;
        }
      });

      // Prevent scroll when viewer is active
      document.addEventListener("keydown", (e) => {
        if (this.isActive && ["ArrowUp", "ArrowDown", "Space"].includes(e.key)) {
          e.preventDefault();
        }
      });
    }

    

    // Lock page scroll without jumping to the top.
    // We store previous inline styles in data-* so it can be safely restored even across Astro page transitions.
    private lockBodyScroll(): void {
      const body = document.body;
      if (body.dataset.pvLocked === "true") return;

      const scrollY = window.scrollY || document.documentElement.scrollTop || 0;

      body.dataset.pvLocked = "true";
      body.dataset.pvScrollY = String(scrollY);

      // Backup current inline styles
      body.dataset.pvOverflow = body.style.overflow || "";
      body.dataset.pvPosition = body.style.position || "";
      body.dataset.pvTop = body.style.top || "";
      body.dataset.pvLeft = body.style.left || "";
      body.dataset.pvRight = body.style.right || "";
      body.dataset.pvWidth = body.style.width || "";

      // Lock scroll while keeping the visual position
      body.style.overflow = "hidden";
      body.style.position = "fixed";
      body.style.top = `-${scrollY}px`;
      body.style.left = "0";
      body.style.right = "0";
      body.style.width = "100%";
    }

    private unlockBodyScroll(): void {
      const body = document.body;
      if (body.dataset.pvLocked !== "true") return;

      const scrollY = parseInt(body.dataset.pvScrollY || "0", 10) || 0;

      // Restore previous inline styles
      body.style.overflow = body.dataset.pvOverflow || "";
      body.style.position = body.dataset.pvPosition || "";
      body.style.top = body.dataset.pvTop || "";
      body.style.left = body.dataset.pvLeft || "";
      body.style.right = body.dataset.pvRight || "";
      body.style.width = body.dataset.pvWidth || "";

      // Cleanup
      delete body.dataset.pvLocked;
      delete body.dataset.pvScrollY;
      delete body.dataset.pvOverflow;
      delete body.dataset.pvPosition;
      delete body.dataset.pvTop;
      delete body.dataset.pvLeft;
      delete body.dataset.pvRight;
      delete body.dataset.pvWidth;

      // Restore scroll position
      window.scrollTo(0, scrollY);
    }
public open(photos: Photo[], startIndex: number = 0): void {
      if (!photos || photos.length === 0) return;
      
      // Clear previous state completely
      this.clearState();
      
      // Set new photos and index
      this.photos = [...photos]; // Create a copy to avoid reference issues
      this.currentIndex = Math.max(0, Math.min(startIndex, photos.length - 1));
      this.isActive = true;

      // Show viewer
      this.viewer.classList.remove("opacity-0", "pointer-events-none");
      this.viewer.classList.add("opacity-100");
      this.viewer.dataset.viewerActive = "true";
      
      // Prevent body scroll (without jumping to top)
      this.lockBodyScroll();
      
      // Load and show current photo
      this.updatePhoto();
      this.updateNavigation();
    }

    public close(): void {
      this.isActive = false;
      
      // Hide viewer
      this.viewer.classList.add("opacity-0", "pointer-events-none");
      this.viewer.classList.remove("opacity-100");
      this.viewer.dataset.viewerActive = "false";
      
      // Restore body scroll
      this.unlockBodyScroll();
      
      // Clear all state
      this.clearState();
    }

    public next(): void {
      if (this.currentIndex < this.photos.length - 1) {
        this.currentIndex++;
        this.updatePhoto();
        this.updateNavigation();
      }
    }

    public previous(): void {
      if (this.currentIndex > 0) {
        this.currentIndex--;
        this.updatePhoto();
        this.updateNavigation();
      }
    }

    private updatePhoto(): void {
      const photo = this.photos[this.currentIndex];
      if (!photo) return;

      // Show loading
      this.loading.style.display = "flex";
      this.image.style.opacity = "0";

      // Preload image
      const img = new Image();
      
      img.onload = () => {
        this.image.src = photo.url;
        this.image.alt = photo.alt;
        this.loading.style.display = "none";
        this.image.style.opacity = "1";
        this.updateInfo();
      };

      img.onerror = () => {
        console.error("Failed to load image:", photo.url);
        this.loading.style.display = "none";
        this.updateInfo();
      };

      img.src = photo.url;
    }

    private updateInfo(): void {
      // Update counter
      this.counter.textContent = `${this.currentIndex + 1} / ${this.photos.length}`;
      
      // Update title
      const photo = this.photos[this.currentIndex];
      this.title.textContent = photo?.alt || "";
    }

    private updateNavigation(): void {
      const hasMultiplePhotos = this.photos.length > 1;
      
      if (hasMultiplePhotos) {
        // Show nav buttons
        this.prevBtn.classList.remove("opacity-0", "pointer-events-none");
        this.nextBtn.classList.remove("opacity-0", "pointer-events-none");
        
        // Update button states
        this.prevBtn.style.opacity = this.currentIndex === 0 ? "0.3" : "1";
        this.nextBtn.style.opacity = this.currentIndex === this.photos.length - 1 ? "0.3" : "1";
        
        this.prevBtn.disabled = this.currentIndex === 0;
        this.nextBtn.disabled = this.currentIndex === this.photos.length - 1;
      } else {
        // Hide nav buttons for single photo
        this.prevBtn.classList.add("opacity-0", "pointer-events-none");
        this.nextBtn.classList.add("opacity-0", "pointer-events-none");
      }
    }

    public isReady(): boolean {
      return !!this.viewer;
    }

    private clearState(): void {
      // Clear photos array
      this.photos = [];
      this.currentIndex = 0;
      
      // Clear image
      this.image.src = "";
      this.image.alt = "";
      this.image.style.opacity = "0";
      
      // Hide loading
      this.loading.style.display = "none";
      
      // Clear info
      this.counter.textContent = "";
      this.title.textContent = "";
      
      // Hide navigation
      this.prevBtn.classList.add("opacity-0", "pointer-events-none");
      this.nextBtn.classList.add("opacity-0", "pointer-events-none");
    }
  }

  // Global instance
  let photoViewer: PhotoViewerSystem;

  // Initialize when DOM is ready
  function initPhotoViewer() {
    // Safety: if a previous viewer left the body locked (e.g., during an Astro transition),
    // unlock it so the page doesn't get stuck or jump unexpectedly.
    try {
      const body = document.body;
      if (body?.dataset?.pvLocked === "true") {
        const y = parseInt(body.dataset.pvScrollY || "0", 10) || 0;

        body.style.overflow = body.dataset.pvOverflow || "";
        body.style.position = body.dataset.pvPosition || "";
        body.style.top = body.dataset.pvTop || "";
        body.style.left = body.dataset.pvLeft || "";
        body.style.right = body.dataset.pvRight || "";
        body.style.width = body.dataset.pvWidth || "";

        delete body.dataset.pvLocked;
        delete body.dataset.pvScrollY;
        delete body.dataset.pvOverflow;
        delete body.dataset.pvPosition;
        delete body.dataset.pvTop;
        delete body.dataset.pvLeft;
        delete body.dataset.pvRight;
        delete body.dataset.pvWidth;

        window.scrollTo(0, y);
      }
    } catch {}

    photoViewer = new PhotoViewerSystem();
    
    // Make globally available with proper typing
    (window as unknown as WindowWithPhotoViewer).openPhotoViewer = (photos: Photo[], index: number = 0) => {
      if (photoViewer?.isReady()) {
        // Add debug logging to verify correct photos are being passed
        console.log("Opening PhotoViewer with", photos.length, "photos, starting at index", index);
        photoViewer.open(photos, index);
      } else {
        console.warn("PhotoViewer not ready");
      }
    };

    (window as unknown as WindowWithPhotoViewer).photoViewerReady = true;
    
    // Dispatch ready event
    document.dispatchEvent(new CustomEvent("photoViewerReady"));
  }

  // Initialize
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initPhotoViewer);
  } else {
    initPhotoViewer();
  }

  // Handle page transitions (for Astro)
  document.addEventListener("astro:page-load", initPhotoViewer);
</script>

<style>
  /* Smooth transitions */
  #photo-viewer {
    transition: opacity 300ms cubic-bezier(0.4, 0, 0.2, 1);
  }

  /* Ensure backdrop blur works on all browsers */
  @supports (backdrop-filter: blur(8px)) {
    #photo-viewer {
      backdrop-filter: blur(8px);
    }
  }

  /* Button hover effects */
  #photo-viewer button:hover {
    transform: scale(1.05);
  }

  #photo-viewer button:active {
    transform: scale(0.95);
  }

  /* Loading animation */
  @keyframes spin {
    to {
      transform: rotate(360deg);
    }
  }

  #viewer-loading .animate-spin {
    animation: spin 1s linear infinite;
  }
</style>